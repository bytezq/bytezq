---
title: 并发
lang: zh-CN
---

从最简单的40s的计算机模型说起, 计算机只有一个逻辑运算单元, 只允许一个程序运行, 并且没有什么API, 程序直接操纵硬件.

到50s年代, 计算能力提升, 但是IO很慢, 中断出现.
可以想象, 十个卡片机上面有个指示灯, 绿灯表示读取完成, 红灯表示正在读取, 同时计算单元(那时候还是一个很大的盒子)上也有一个指示灯, 绿灯表示正在计算, 红灯表示计算完成. 旁边有一个工作人员, 看到哪个卡片机读取完成, 并且计算机也已经计算完成, 就拨一下摇杆, 就手动切换一下.
同时, 为了方便变成, 计算还提供了一些 Syscall API(读取指令 加指令 跳转指令等), 这就是最简单的操作系统.

程序只能做计算, 只是状态的迁移, 加上syscall, 就可以完成一些系统的操作.

手动切换还是太麻烦了, 能不能定时中断, 分时系统出现了, 这是syscall也多了一些, 比如读文件的指令.

共享内存, 多进程也出现.

一个程序切换到另一个程序, 需要保存私有的数据: pc(下一个指令的位置) + 寄存器的状态, 栈数据等.

并发性的来源:进程会调用操作系统的api.

    write(fd, buf, 1 Tib)(Tib宏)

    write的实现是操作系统的一部分.

      x86-64应用程序执行syscall后就进入操作系统执行(应用程序不可见).

      运行在处理器的高特权级:能访问硬件设备.

      但又不能一直霸占处理器运行(否则系统就卡死了)

因此必须允许write到一半的时候,让另一个进程执行.

      另一个进程调用read(fd, buf, 512 Mib)读取同一个文件.

      操作系统代码并发了: 操作系统api实现需要考虑并发.

      

thread可以共享内存, 也有线程私有变量

经典的问题, 两个线程同时执行 i++, 或者求和, 会发生什么?

::: tip
多线程共享内存, 导致原子性的丧失, "程序 (甚至是一条指令) 独占处理器执行"的基本假设在现代多处理器系统上不再成立。
:::

原子性：一段代码执行独占整个计算机系统

- 单处理器多线程
  - 线程在运行时可能被中断，切换到另一个线程执行
- 多处理器多线程
  - 线程根本就是并行执行的

(历史) 1960s，大家争先在共享内存上实现原子性 (互斥)
但几乎所有的实现都是错的，直到 Dekker's Algorithm，还只能保证两个线程的互斥

互斥和原子性是本学期的重要主题
- lock(&lk)
- unlock(&lk)
  - 实现临界区 (critical section) 之间的绝对串行化
  - 程序的其他部分依然可以并行执行

99% 的并发问题都可以用一个队列解决
- 把大任务切分成可以并行的小任务
- worker thread 去锁保护的队列里取任务
- 除去不可并行的部分，剩下的部分可以获得线性的加速

https://web.mit.edu/dimitrib/www/pdc.html

::: tip
顺序的丧失, 编译器对内存访问 “eventually consistent” 的处理导致共享内存作为线程同步工具的失效。
:::

### 多处理器间可见性的丧失

```c
int x = 0, y = 0;

void T1() {
  x = 1;
  asm volatile("" : : "memory"); // compiler barrier
  printf("y = %d\n", y);
}

void T2() {
  y = 1;
  asm volatile("" : : "memory"); // compiler barrier
  printf("x = %d\n", x);
}
```

问题：我们最终能看到哪些结果？
- 输出不好读？pipe to head -n 1000000 | sort | uniq -c


单个处理器把汇编代码 (用电路) “编译” 成更小的 μops
- RF[9] = load(RF[7] + 400)
- store(RF[12], RF[13])
- RF[3] = RF[4] + RF[5]
每个 μop 都有 Fetch, Issue, Execute, Commit 四个阶段

在任何时刻，处理器都维护一个 μop 的 “池子”

- 每一周期向池子补充尽可能多的 μop
  - “多发射”
- 每一周期 (在不违反编译正确性的前提下) 执行尽可能多的 μop
  - “乱序执行”、“按序提交”

这就是《计算机体系结构》 (剩下就是木桶效应，哪里短板补哪里)

满足单处理器 eventual memory consistency 的执行，在多处理器上可能无法序列化！

当 x != y 时, 对 x, y 的内存读写可以交换顺序

- 它们甚至可以在同一个周期里完成 (只要 load/store unit 支持)
- 如果写 x 发生 cache miss，可以让读 y 先执行
  - 满足 “尽可能执行μop” 的原则，最大化处理器性能

```asm
     # <-----------+
movl $1, (x)   #   |
movl (y), %eax # --+
```

- 在多处理器上的表现
- 两个处理器分别看到 y=0 和 x=0

并发编程, 保证:

- 原子性(一条指令被拆成多条执行)
- 顺序性(高级语言编译器优化对汇编指令重排序)
- 可见性(多处理器, 汇编指令转为cpu执行的μop指令, 一个指令周期内, 两个cpu执行两个指令, 缓存miss, 两个变量都为0)

互斥和原子性
1. 基于共享内存 Peterson 算法


