---
title: 操作系统概述
lang: zh-CN
---

# 概述

- (Why)为什么要学操作系统？为了变得更强.
- (What)到底什么是操作系统？没有精确地定义, 学完你就知道了.
- (How)怎么学操作系统？多动手.

微积分 “被混起来” 的几件事

- Newton 时代的微积分 (启蒙与应用)
  - 现代方法：Mathematica, sympy, sage 
- Cauchy 时代的微积分 (严格化与公理化)
  - 以及之后各种卡出的 bug (Weierstrass 函数、Peano 曲线……)
- 微积分的现代应用
  - 优化、有限元、PID ...

### 什么是操作系统?

精准” 的定义毫无意义

问出正确的问题：操作系统如何从一开始变成现在这样的？

三个重要的线索:
- 计算机 (硬件)
- 程序 (软件)
- 操作系统 (管理软件的软件)

本课程讨论狭义的操作系统
- 对单一计算机硬件系统作出抽象、支撑程序执行的软件系统
- 学术界谈论 “操作系统” 是更广义的 “System” (例子：OSDI/SOSP)

### 从操作系统的历史说起

1940s的计算机
跨时代、非凡的天才设计，但很简单 (还不如我们数电实验课做的 CPU 复杂呢)：
- 计算机系统 = 状态机 (ICS 课程的 takeaway message)
- 标准的 Mealy 型数字电路
  - ENIAC (1946.2.14；请在这个特殊的节日多陪陪你的电脑)

电子计算机的实现
- 逻辑门：真空电子管
- 存储器：延迟线 (delay lines)
- 输入/输出：打孔纸带/指示灯

ENIAC 程序是用物理线路 “hard-wire” 的
- 重编程需要重新接线

能把程序放上去就很了不起了
- 程序直接用指令操作硬件
- 不需要画蛇添足的程序来管理它

1950s的计算机
更快更小的逻辑门 (晶体管)、更大的内存 (磁芯)、丰富的 I/O 设备
- I/O 设备的速度已经严重低于处理器的速度，中断机制出现 (1953)

可以执行更复杂的任务，包括通用的计算任务
- 希望使用计算机的人越来越多；希望调用 API 而不是直接访问设备
- Fortran 诞生 (1957)

写程序、跑程序都是非常费事的 (比如你写了个死循环……)
- 计算机非常贵 (\$50,000-\$1,000,000)，一个学校只有一台
- 产生了集中管理计算机的需求：多用户排队共享计算机

操作系统的概念开始形成
- 操作 (operate) 任务 (jobs) 的系统 (system)
  - “批处理系统” = 程序的自动切换 (换卡) + 库函数 API
  - Disk Operating Systems (DOS)
    - 操作系统中开始出现 “设备”、“文件”、“任务” 等对象和 API

1960s的计算机
集成电路、总线出现
- 更快的处理器
- 更快、更大的内存；虚拟存储出现
  - 可以同时载入多个程序而不用 “换卡” 了
- 更丰富的 I/O 设备；完善的中断/异常机制

更多的高级语言和编译器出现
- COBOL (1960), APL (1962), BASIC (1965)
- Bill Gates 和 Paul Allen 在 1975 年实现了 Altair 8800 上的 BASIC 解释器

::: tip
能载入多个程序到内存且灵活调度它们的管理程序，包括程序可以调用的 API。
:::

同时将多个程序载入内存是一项巨大的能力

- 有了进程 (process) 的概念
- 进程在执行 I/O 时，可以将 CPU 让给另一个进程
  - 在多个地址空间隔离的程序之间切换
  - 虚拟存储使一个程序出 bug 不会 crash 整个系统

操作系统中自然地增加进程管理 API

::: tip
既然操作系统已经可以在程序之间切换，为什么不让它们定时切换呢？
:::
基于中断 (例如时钟) 机制

- 时钟中断：使程序在执行时，异步地插入函数调用
- 由操作系统 (调度策略) 决定是否要切换到另一个程序执行
- Multics (MIT, 1965)
  - 现代操作系统诞生

1970s的计算机
集成电路空前发展，个人电脑兴起，“计算机” 已与今日无大异

- CISC 指令集；中断、I/O、异常、MMU、网络
- 个人计算机 (PC 机)、超级计算机

PASCAL (1970), C (1972)
- 今天能办到的，那个时代已经都能办到了——上天入地、图像声音视频、人工智能
- 个人开发者 (Geek Network) 走上舞台

- 1973: 信号 API、管道 (对象)、grep (应用程序)
- 1983: BSD socket (对象)
- 1984: procfs (对象)
- UNIX 衍生出的大家族
  - 1BSD (1977), GNU (1983), MacOS (1984), AIX (1986), Minix (1987), Windows (1985), Linux 0.01 (1991), Windows NT (1993), Debian (1996), Windows XP (2002), Ubuntu (2004), iOS (2007), Android (2008), Windows 10 (2015)

今天的操作系统
空前复杂的系统之一

- 更复杂的处理器和内存
  - 非对称多处理器 (ARM big.LITTLE; Intel P/E-cores)
  - Non-uniform Memory Access (NUMA)
  - 更多的硬件机制 Intel-VT/AMD-V, TrustZone/SGX, TSX
- 更多的设备和资源
  - 网卡、SSD、GPU、FPGA...
- 复杂的应用需求和应用环境
  - 服务器、个人电脑、智能手机、手表、手环、IoT/微控制器

### 理解操作系统: 三个根本的问题
操作系统服务谁？
 - 程序 = 状态机
 - 课程涉及：多线程 Linux 应用程序

(设计/程序视角) 操作系统为程序提供什么服务？
- 操作系统 = 对象 + API
- 课程涉及：POSIX + 部分 Linux 特性

(实现/硬件视角) 如何实现操作系统提供的服务？
- 操作系统就是一个 C 程序
  - 完成初始化后就成为 interrupt/trap/fault handler
- 课程涉及：xv6, 自制迷你操作系统



# 程序
程序就是状态机.

